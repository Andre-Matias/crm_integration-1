var params = {
  from: '2017-08-01',
  to: '2017-08-07',
  timeout: 30*60*1000,
  h24: 1000*60*60*24,
};
function main() {
  return Events({
    from_date: params.from,
    to_date: params.to
  })
  .filter(event => event.properties.platform === "desktop")
  .filter(event => event.properties.event_type === "pv")
  .groupByUser([event => getDay(event.time)], function(state, events){
    state = state || {pv: 0, sessions: 0, bounces: 0, pvPerSession: 0, dateSession: null, previousEvent:0, totaltime:0 };
    _.each(events, function(e, i){
      // if the event is a page view, then +1
      if (e.properties.event_type === 'pv'){
        state.pv++;
      }
      
      // if the event is happening 30 min later or more than the previous one, +1 session
      if (e.time - state.previousEvent >= params.timeout){
        state.sessions++;
        // if the pvPerSession is 1, then +1 to the bounce to the correct date, where the session started actually
        if (state.pvPerSession === 1){
          state.bounces++;
        }
        // then provide then update the dateSession and add 1 tp pvPerSession
        state.dateSession = getDay(e.time);
        state.pvPerSession = 1;
      }
      // if it's not a new session, increase the pvPerSession
      else {
        state.totaltime+=(e.time-state.previousEvent);
        state.pvPerSession++;
      }
      // if the last event is a bounce, add it
      if (state.pvPerSession === 1 && (i+1) === events.length){
          state.bounces++;
        }
      // provide the timestamp of the current event to use it for the next event
      state.previousEvent = e.time;
      // end forEach
    });
    state.pvPerSession=0;
    state.dateSession=0;
    state.previousEvent=0;
    return state;
})
.map(function(item){
  var obj = {
    pv: {},
    sessions: {},
    bounces: {},
    totaltime: {}
  };
  obj.date = item.key[1];
  obj.pv = Number(item.value.pv);
  obj.sessions = Number(item.value.sessions);
  //obj.bounces = Number(item.value.bounces);
  //obj.totaltime = Number(item.value.totaltime)/1000;
    return obj;
})
.groupBy([function(item) {
  var date = item.date;
  delete item.date;
  return date;
}], mixpanel.reducer.object_merge());
}

function makeDays(to, from) {
  var obj = {};
  var start = new Date(from);
  var end = new Date(new Date(to).getTime() + 60 * 60 * 24 * 1000);
  var current = start;
  var seconds = 1000 * 60 * 60 * 24;
  while(current < end) {
    obj[current.toISOString().substring(0,10)] = 0;
    current = new Date(current.getTime() + seconds);
  }
  return obj;
}

function getDay(unix) {
  return new Date(unix).toISOString().substring(0,10);
}
